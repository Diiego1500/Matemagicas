!function (t) {
    "use strict";

    function e() {
    }

    function i(t) {
        if (!t || "object" != typeof t) return !1;
        var e = z(t) || me;
        return /object|function/.test(typeof e.Element) ? t instanceof e.Element : 1 === t.nodeType && "string" == typeof t.nodeName
    }

    function r(t) {
        return t === me || !(!t || !t.Window) && t instanceof t.Window
    }

    function s(t) {
        return !!t && t instanceof ye
    }

    function n(t) {
        return o(t) && void 0 !== typeof t.length && a(t.splice)
    }

    function o(t) {
        return !!t && "object" == typeof t
    }

    function a(t) {
        return "function" == typeof t
    }

    function h(t) {
        return "number" == typeof t
    }

    function p(t) {
        return "boolean" == typeof t
    }

    function l(t) {
        return "string" == typeof t
    }

    function c(t) {
        return l(t) ? (fe.querySelector(t), !0) : !1
    }

    function d(t, e) {
        for (var i in e) t[i] = e[i];
        return t
    }

    function u(t, e) {
        for (var i in e) {
            var r = !1;
            for (var s in Ke) if (0 === i.indexOf(s) && Ke[s].test(i)) {
                r = !0;
                break
            }
            r || (t[i] = e[i])
        }
        return t
    }

    function g(t, e) {
        t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp
    }

    function v(t, e, i) {
        var r = e.length > 1 ? M(e) : e[0];
        x(r, De, i), t.page.x = De.x, t.page.y = De.y, E(r, De, i), t.client.x = De.x, t.client.y = De.y, t.timeStamp = (new Date).getTime()
    }

    function m(t, e, i) {
        t.page.x = i.page.x - e.page.x, t.page.y = i.page.y - e.page.y, t.client.x = i.client.x - e.client.x, t.client.y = i.client.y - e.client.y, t.timeStamp = (new Date).getTime() - e.timeStamp;
        var r = Math.max(t.timeStamp / 1e3, .001);
        t.page.speed = ze(t.page.x, t.page.y) / r, t.page.vx = t.page.x / r, t.page.vy = t.page.y / r, t.client.speed = ze(t.client.x, t.page.y) / r, t.client.vx = t.client.x / r, t.client.vy = t.client.y / r
    }

    function f(t) {
        return t instanceof me.Event || ke && me.Touch && t instanceof me.Touch
    }

    function y(t, e, i) {
        return i = i || {}, t = t || "page", i.x = e[t + "X"], i.y = e[t + "Y"], i
    }

    function x(t, e) {
        return e = e || {}, Ve && f(t) ? (y("screen", t, e), e.x += me.scrollX, e.y += me.scrollY) : y("page", t, e), e
    }

    function E(t, e) {
        return e = e || {}, Ve && f(t) ? y("screen", t, e) : y("client", t, e), e
    }

    function S(t) {
        return t = t || me, {
            x: t.scrollX || t.document.documentElement.scrollLeft,
            y: t.scrollY || t.document.documentElement.scrollTop
        }
    }

    function b(t) {
        return h(t.pointerId) ? t.pointerId : t.identifier
    }

    function w(t) {
        return t instanceof Se ? t.correspondingUseElement : t
    }

    function z(t) {
        if (r(t)) return t;
        var e = t.ownerDocument || t;
        return e.defaultView || e.parentWindow || me
    }

    function D(t) {
        var e = t instanceof xe ? t.getBoundingClientRect() : t.getClientRects()[0];
        return e && {
            left: e.left,
            right: e.right,
            top: e.top,
            bottom: e.bottom,
            width: e.width || e.right - e.left,
            height: e.height || e.bottom - e.top
        }
    }

    function T(t) {
        var e = D(t);
        if (!$e && e) {
            var i = S(z(t));
            e.left += i.x, e.right += i.x, e.top += i.y, e.bottom += i.y
        }
        return e
    }

    function C(t) {
        var e = [];
        return n(t) ? (e[0] = t[0], e[1] = t[1]) : "touchend" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e
    }

    function M(t) {
        for (var e, i = {
            pageX: 0,
            pageY: 0,
            clientX: 0,
            clientY: 0,
            screenX: 0,
            screenY: 0
        }, r = 0; r < t.length; r++) for (e in i) i[e] += t[r][e];
        for (e in i) i[e] /= t.length;
        return i
    }

    function P(t) {
        if (t.length || t.touches && t.touches.length > 1) {
            var e = C(t), i = Math.min(e[0].pageX, e[1].pageX), r = Math.min(e[0].pageY, e[1].pageY),
                s = Math.max(e[0].pageX, e[1].pageX), n = Math.max(e[0].pageY, e[1].pageY);
            return {x: i, y: r, left: i, top: r, width: s - i, height: n - r}
        }
    }

    function A(t, e) {
        e = e || Oe.deltaSource;
        var i = e + "X", r = e + "Y", s = C(t), n = s[0][i] - s[1][i], o = s[0][r] - s[1][r];
        return ze(n, o)
    }

    function O(t, e, i) {
        i = i || Oe.deltaSource;
        var r = i + "X", s = i + "Y", n = C(t), o = n[0][r] - n[1][r], a = n[0][s] - n[1][s],
            p = 180 * Math.atan(a / o) / Math.PI;
        if (h(e)) {
            var l = p - e, c = l % 360;
            c > 315 ? p -= 360 + p / 360 | 0 : c > 135 ? p -= 180 + p / 360 | 0 : -315 > c ? p += 360 + p / 360 | 0 : -135 > c && (p += 180 + p / 360 | 0)
        }
        return p
    }

    function _(t, e) {
        var r = t ? t.options.origin : Oe.origin;
        return "parent" === r ? r = F(e) : "self" === r ? r = t.getRect(e) : c(r) && (r = I(e, r) || {
            x: 0,
            y: 0
        }), a(r) && (r = r(t && e)), i(r) && (r = T(r)), r.x = "x" in r ? r.x : r.left, r.y = "y" in r ? r.y : r.top, r
    }

    function k(t, e, i, r) {
        var s = 1 - t;
        return s * s * e + 2 * s * t * i + t * t * r
    }

    function X(t, e, i, r, s, n, o) {
        return {x: k(o, t, i, s), y: k(o, e, r, n)}
    }

    function Y(t, e, i, r) {
        return t /= r, -i * t * (t - 2) + e
    }

    function R(t, e) {
        for (; e;) {
            if (e === t) return !0;
            e = e.parentNode
        }
        return !1
    }

    function I(t, e) {
        for (var r = F(t); i(r);) {
            if (de(r, e)) return r;
            r = F(r)
        }
        return null
    }

    function F(t) {
        var e = t.parentNode;
        if (s(e)) {
            for (; (e = e.host) && s(e);) ;
            return e
        }
        return e
    }

    function q(t, e) {
        return t._context === e.ownerDocument || R(t._context, e)
    }

    function N(t, e, r) {
        var s = t.options.ignoreFrom;
        return s && i(r) ? l(s) ? ue(r, s, e) : i(s) ? R(s, r) : !1 : !1
    }

    function H(t, e, r) {
        var s = t.options.allowFrom;
        return s ? i(r) ? l(s) ? ue(r, s, e) : i(s) ? R(s, r) : !1 : !1 : !0
    }

    function W(t, e) {
        if (!e) return !1;
        var i = e.options.drag.axis;
        return "xy" === t || "xy" === i || i === t
    }

    function U(t, e) {
        var i = t.options;
        return /^resize/.test(e) && (e = "resize"), i[e].snap && i[e].snap.enabled
    }

    function V(t, e) {
        var i = t.options;
        return /^resize/.test(e) && (e = "resize"), i[e].restrict && i[e].restrict.enabled
    }

    function $(t, e) {
        var i = t.options;
        return /^resize/.test(e) && (e = "resize"), i[e].autoScroll && i[e].autoScroll.enabled
    }

    function G(t, e, i) {
        for (var r = t.options, s = r[i.name].max, n = r[i.name].maxPerElement, o = 0, a = 0, h = 0, p = 0, l = Me.length; l > p; p++) {
            var c = Me[p], d = c.prepared.name, u = c.interacting();
            if (u) {
                if (o++, o >= Fe) return !1;
                if (c.target === t) {
                    if (a += d === i.name | 0, a >= s) return !1;
                    if (c.element === e && (h++, d !== i.name || h >= n)) return !1
                }
            }
        }
        return Fe > 0
    }

    function L(t) {
        var e, i, r, s, n, o = t[0], a = o ? 0 : -1, h = [], p = [];
        for (s = 1; s < t.length; s++) if (e = t[s], e && e !== o) if (o) {
            if (e.parentNode !== e.ownerDocument) if (o.parentNode !== e.ownerDocument) {
                if (!h.length) for (i = o; i.parentNode && i.parentNode !== i.ownerDocument;) h.unshift(i), i = i.parentNode;
                if (o instanceof be && e instanceof xe && !(e instanceof Ee)) {
                    if (e === o.parentNode) continue;
                    i = e.ownerSVGElement
                } else i = e;
                for (p = []; i.parentNode !== i.ownerDocument;) p.unshift(i), i = i.parentNode;
                for (n = 0; p[n] && p[n] === h[n];) n++;
                var l = [p[n - 1], p[n], h[n]];
                for (r = l[0].lastChild; r;) {
                    if (r === l[1]) {
                        o = e, a = s, h = [];
                        break
                    }
                    if (r === l[2]) break;
                    r = r.previousSibling
                }
            } else o = e, a = s
        } else o = e, a = s;
        return a
    }

    function j() {
        if (this.target = null, this.element = null, this.dropTarget = null, this.dropElement = null, this.prevDropTarget = null, this.prevDropElement = null, this.prepared = {
                name: null,
                axis: null,
                edges: null
            }, this.matches = [], this.matchElements = [], this.inertiaStatus = {
                active: !1,
                smoothEnd: !1,
                ending: !1,
                startEvent: null,
                upCoords: {},
                xe: 0,
                ye: 0,
                sx: 0,
                sy: 0,
                t0: 0,
                vx0: 0,
                vys: 0,
                duration: 0,
                resumeDx: 0,
                resumeDy: 0,
                lambda_v0: 0,
                one_ve_v0: 0,
                i: null
            }, a(Function.prototype.bind)) this.boundInertiaFrame = this.inertiaFrame.bind(this), this.boundSmoothEndFrame = this.smoothEndFrame.bind(this); else {
            var t = this;
            this.boundInertiaFrame = function () {
                return t.inertiaFrame()
            }, this.boundSmoothEndFrame = function () {
                return t.smoothEndFrame()
            }
        }
        this.activeDrops = {
            dropzones: [],
            elements: [],
            rects: []
        }, this.pointers = [], this.pointerIds = [], this.downTargets = [], this.downTimes = [], this.holdTimers = [], this.prevCoords = {
            page: {
                x: 0,
                y: 0
            }, client: {x: 0, y: 0}, timeStamp: 0
        }, this.curCoords = {page: {x: 0, y: 0}, client: {x: 0, y: 0}, timeStamp: 0}, this.startCoords = {
            page: {
                x: 0,
                y: 0
            }, client: {x: 0, y: 0}, timeStamp: 0
        }, this.pointerDelta = {
            page: {x: 0, y: 0, vx: 0, vy: 0, speed: 0},
            client: {x: 0, y: 0, vx: 0, vy: 0, speed: 0},
            timeStamp: 0
        }, this.downEvent = null, this.downPointer = {}, this._eventTarget = null, this._curEventTarget = null, this.prevEvent = null, this.tapTime = 0, this.prevTap = null, this.startOffset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, this.restrictOffset = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, this.snapOffsets = [], this.gesture = {
            start: {x: 0, y: 0},
            startDistance: 0,
            prevDistance: 0,
            distance: 0,
            scale: 1,
            startAngle: 0,
            prevAngle: 0
        }, this.snapStatus = {
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            realX: 0,
            realY: 0,
            snappedX: 0,
            snappedY: 0,
            targets: [],
            locked: !1,
            changed: !1
        }, this.restrictStatus = {
            dx: 0,
            dy: 0,
            restrictedX: 0,
            restrictedY: 0,
            snap: null,
            restricted: !1,
            changed: !1
        }, this.restrictStatus.snap = this.snapStatus, this.pointerIsDown = !1, this.pointerWasMoved = !1, this.gesturing = !1, this.dragging = !1, this.resizing = !1, this.resizeAxes = "xy", this.mouse = !1, Me.push(this)
    }

    function B(t, e, i) {
        var r, s = 0, n = Me.length, o = /mouse/i.test(t.pointerType || e) || 4 === t.pointerType, a = b(t);
        if (/down|start/i.test(e)) for (s = 0; n > s; s++) {
            r = Me[s];
            var h = i;
            if (r.inertiaStatus.active && r.target.options[r.prepared.name].inertia.allowResume && r.mouse === o) for (; h;) {
                if (h === r.element) return r;
                h = F(h)
            }
        }
        if (o || !ke && !Xe) {
            for (s = 0; n > s; s++) if (Me[s].mouse && !Me[s].inertiaStatus.active) return Me[s];
            for (s = 0; n > s; s++) if (Me[s].mouse && (!/down/.test(e) || !Me[s].inertiaStatus.active)) return r;
            return r = new j, r.mouse = !0, r
        }
        for (s = 0; n > s; s++) if (ce(Me[s].pointerIds, a)) return Me[s];
        if (/up|end|out/i.test(e)) return null;
        for (s = 0; n > s; s++) if (r = Me[s], !(r.prepared.name && !r.target.options.gesture.enabled || r.interacting() || !o && r.mouse)) return r;
        return new j
    }

    function K(t) {
        return function (e) {
            var i, r, s = w(e.path ? e.path[0] : e.target), n = w(e.currentTarget);
            if (ke && /touch/.test(e.type)) for (Ie = (new Date).getTime(), r = 0; r < e.changedTouches.length; r++) {
                var o = e.changedTouches[r];
                i = B(o, e.type, s), i && (i._updateEventTargets(s, n), i[t](o, e, s, n))
            } else {
                if (!Xe && /mouse/.test(e.type)) {
                    for (r = 0; r < Me.length; r++) if (!Me[r].mouse && Me[r].pointerIsDown) return;
                    if ((new Date).getTime() - Ie < 500) return
                }
                if (i = B(e, e.type, s), !i) return;
                i._updateEventTargets(s, n), i[t](e, e, s, n)
            }
        }
    }

    function J(t, e, i, r, s, n) {
        var o, a, h = t.target, p = t.snapStatus, l = t.restrictStatus, c = t.pointers,
            u = (h && h.options || Oe).deltaSource, g = u + "X", v = u + "Y", m = h ? h.options : Oe, f = _(h, s),
            y = "start" === r, x = "end" === r, E = y ? t.startCoords : t.curCoords;
        s = s || t.element, a = d({}, E.page), o = d({}, E.client), a.x -= f.x, a.y -= f.y, o.x -= f.x, o.y -= f.y;
        var S = m[i].snap && m[i].snap.relativePoints;
        !U(h, i) || y && S && S.length || (this.snap = {
            range: p.range,
            locked: p.locked,
            x: p.snappedX,
            y: p.snappedY,
            realX: p.realX,
            realY: p.realY,
            dx: p.dx,
            dy: p.dy
        }, p.locked && (a.x += p.dx, a.y += p.dy, o.x += p.dx, o.y += p.dy)), !V(h, i) || y && m[i].restrict.elementRect || !l.restricted || (a.x += l.dx, a.y += l.dy, o.x += l.dx, o.y += l.dy, this.restrict = {
            dx: l.dx,
            dy: l.dy
        }), this.pageX = a.x, this.pageY = a.y, this.clientX = o.x, this.clientY = o.y, this.x0 = t.startCoords.page.x - f.x, this.y0 = t.startCoords.page.y - f.y, this.clientX0 = t.startCoords.client.x - f.x, this.clientY0 = t.startCoords.client.y - f.y, this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.button = e.button, this.buttons = e.buttons, this.target = s, this.t0 = t.downTimes[0], this.type = i + (r || ""), this.interaction = t, this.interactable = h;
        var b = t.inertiaStatus;
        if (b.active && (this.detail = "inertia"), n && (this.relatedTarget = n), x ? "client" === u ? (this.dx = o.x - t.startCoords.client.x, this.dy = o.y - t.startCoords.client.y) : (this.dx = a.x - t.startCoords.page.x, this.dy = a.y - t.startCoords.page.y) : y ? (this.dx = 0, this.dy = 0) : "inertiastart" === r ? (this.dx = t.prevEvent.dx, this.dy = t.prevEvent.dy) : "client" === u ? (this.dx = o.x - t.prevEvent.clientX, this.dy = o.y - t.prevEvent.clientY) : (this.dx = a.x - t.prevEvent.pageX, this.dy = a.y - t.prevEvent.pageY), t.prevEvent && "inertia" === t.prevEvent.detail && !b.active && m[i].inertia && m[i].inertia.zeroResumeDelta && (b.resumeDx += this.dx, b.resumeDy += this.dy, this.dx = this.dy = 0), "resize" === i && t.resizeAxes ? m.resize.square ? ("y" === t.resizeAxes ? this.dx = this.dy : this.dy = this.dx, this.axes = "xy") : (this.axes = t.resizeAxes, "x" === t.resizeAxes ? this.dy = 0 : "y" === t.resizeAxes && (this.dx = 0)) : "gesture" === i && (this.touches = [c[0], c[1]], y ? (this.distance = A(c, u), this.box = P(c), this.scale = 1, this.ds = 0, this.angle = O(c, void 0, u), this.da = 0) : x || e instanceof J ? (this.distance = t.prevEvent.distance, this.box = t.prevEvent.box, this.scale = t.prevEvent.scale, this.ds = this.scale - 1, this.angle = t.prevEvent.angle, this.da = this.angle - t.gesture.startAngle) : (this.distance = A(c, u), this.box = P(c), this.scale = this.distance / t.gesture.startDistance, this.angle = O(c, t.gesture.prevAngle, u), this.ds = this.scale - t.gesture.prevScale, this.da = this.angle - t.gesture.prevAngle)), y) this.timeStamp = t.downTimes[0], this.dt = 0, this.duration = 0, this.speed = 0, this.velocityX = 0, this.velocityY = 0; else if ("inertiastart" === r) this.timeStamp = t.prevEvent.timeStamp, this.dt = t.prevEvent.dt, this.duration = t.prevEvent.duration, this.speed = t.prevEvent.speed, this.velocityX = t.prevEvent.velocityX, this.velocityY = t.prevEvent.velocityY; else if (this.timeStamp = (new Date).getTime(), this.dt = this.timeStamp - t.prevEvent.timeStamp, this.duration = this.timeStamp - t.downTimes[0], e instanceof J) {
            var w = this[g] - t.prevEvent[g], z = this[v] - t.prevEvent[v], D = this.dt / 1e3;
            this.speed = ze(w, z) / D, this.velocityX = w / D, this.velocityY = z / D
        } else this.speed = t.pointerDelta[u].speed, this.velocityX = t.pointerDelta[u].vx, this.velocityY = t.pointerDelta[u].vy;
        if ((x || "inertiastart" === r) && t.prevEvent.speed > 600 && this.timeStamp - t.prevEvent.timeStamp < 150) {
            var T = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI, C = 22.5;
            0 > T && (T += 360);
            var M = T >= 135 - C && 225 + C > T, k = T >= 225 - C && 315 + C > T,
                X = !M && (T >= 315 - C || 45 + C > T), Y = !k && T >= 45 - C && 135 + C > T;
            this.swipe = {
                up: k,
                down: Y,
                left: M,
                right: X,
                angle: T,
                speed: t.prevEvent.speed,
                velocity: {x: t.prevEvent.velocityX, y: t.prevEvent.velocityY}
            }
        }
    }

    function Q() {
        this.originalEvent.preventDefault()
    }

    function Z(t) {
        var e = "";
        if ("drag" === t.name && (e = qe.drag), "resize" === t.name) if (t.axis) e = qe[t.name + t.axis]; else if (t.edges) {
            for (var i = "resize", r = ["top", "bottom", "left", "right"], s = 0; 4 > s; s++) t.edges[r[s]] && (i += r[s]);
            e = qe[i]
        }
        return e
    }

    function te(t, e, r, s, n, o, a) {
        if (!e) return !1;
        if (e === !0) {
            var p = h(o.width) ? o.width : o.right - o.left, l = h(o.height) ? o.height : o.bottom - o.top;
            if (0 > p && ("left" === t ? t = "right" : "right" === t && (t = "left")), 0 > l && ("top" === t ? t = "bottom" : "bottom" === t && (t = "top")), "left" === t) return r.x < (p >= 0 ? o.left : o.right) + a;
            if ("top" === t) return r.y < (l >= 0 ? o.top : o.bottom) + a;
            if ("right" === t) return r.x > (p >= 0 ? o.right : o.left) - a;
            if ("bottom" === t) return r.y > (l >= 0 ? o.bottom : o.top) - a
        }
        return i(s) ? i(e) ? e === s : ue(s, e, n) : !1
    }

    function ee(t, e, i) {
        var r, s = this.getRect(i), n = !1, a = null, h = null, p = d({}, e.curCoords.page), l = this.options;
        if (!s) return null;
        if (Ne.resize && l.resize.enabled) {
            var c = l.resize;
            if (r = {left: !1, right: !1, top: !1, bottom: !1}, o(c.edges)) {
                for (var u in r) r[u] = te(u, c.edges[u], p, e._eventTarget, i, s, c.margin || Ye);
                r.left = r.left && !r.right, r.top = r.top && !r.bottom, n = r.left || r.right || r.top || r.bottom
            } else {
                var g = "y" !== l.resize.axis && p.x > s.right - Ye, v = "x" !== l.resize.axis && p.y > s.bottom - Ye;
                n = g || v, h = (g ? "x" : "") + (v ? "y" : "")
            }
        }
        return a = n ? "resize" : Ne.drag && l.drag.enabled ? "drag" : null, Ne.gesture && e.pointerIds.length >= 2 && !e.dragging && !e.resizing && (a = "gesture"), a ? {
            name: a,
            axis: h,
            edges: r
        } : null
    }

    function ie(t, e) {
        if (!o(t)) return null;
        var i = t.name, r = e.options;
        return ("resize" === i && r.resize.enabled || "drag" === i && r.drag.enabled || "gesture" === i && r.gesture.enabled) && Ne[i] ? (("resize" === i || "resizeyx" === i) && (i = "resizexy"), t) : null
    }

    function re(t, e) {
        var r = {}, s = Ae[t.type], n = w(t.path ? t.path[0] : t.target), o = n;
        e = e ? !0 : !1;
        for (var a in t) r[a] = t[a];
        for (r.originalEvent = t, r.preventDefault = Q; i(o);) {
            for (var h = 0; h < s.selectors.length; h++) {
                var p = s.selectors[h], l = s.contexts[h];
                if (de(o, p) && R(l, n) && R(l, o)) {
                    var c = s.listeners[h];
                    r.currentTarget = o;
                    for (var d = 0; d < c.length; d++) c[d][1] === e && c[d][0](r)
                }
            }
            o = F(o)
        }
    }

    function se(t) {
        return re.call(this, t, !0)
    }

    function ne(t, e) {
        return Ce.get(t, e) || new oe(t, e)
    }

    function oe(t, e) {
        this._element = t, this._iEvents = this._iEvents || {};
        var r;
        if (c(t)) {
            this.selector = t;
            var s = e && e.context;
            r = s ? z(s) : me, s && (r.Node ? s instanceof r.Node : i(s) || s === r.document) && (this._context = s)
        } else r = z(t), i(t, r) && (we ? (Be.add(this._element, ge.down, Je.pointerDown), Be.add(this._element, ge.move, Je.pointerHover)) : (Be.add(this._element, "mousedown", Je.pointerDown), Be.add(this._element, "mousemove", Je.pointerHover), Be.add(this._element, "touchstart", Je.pointerDown), Be.add(this._element, "touchmove", Je.pointerHover)));
        this._doc = r.document, ce(Te, this._doc) || pe(this._doc), Ce.push(this), this.set(e)
    }

    function ae(t, e) {
        var i = !1;
        return function () {
            return i || (me.console.warn(e), i = !0), t.apply(this, arguments)
        }
    }

    function he(t) {
        for (var e = 0; e < Me.length; e++) Me[e].pointerEnd(t, t)
    }

    function pe(t) {
        if (!ce(Te, t)) {
            var e = t.defaultView || t.parentWindow;
            for (var i in Ae) Be.add(t, i, re), Be.add(t, i, se, !0);
            we ? (ge = we === e.MSPointerEvent ? {
                up: "MSPointerUp",
                down: "MSPointerDown",
                over: "mouseover",
                out: "mouseout",
                move: "MSPointerMove",
                cancel: "MSPointerCancel"
            } : {
                up: "pointerup",
                down: "pointerdown",
                over: "pointerover",
                out: "pointerout",
                move: "pointermove",
                cancel: "pointercancel"
            }, Be.add(t, ge.down, Je.selectorDown), Be.add(t, ge.move, Je.pointerMove), Be.add(t, ge.over, Je.pointerOver), Be.add(t, ge.out, Je.pointerOut), Be.add(t, ge.up, Je.pointerUp), Be.add(t, ge.cancel, Je.pointerCancel), Be.add(t, ge.move, Je.autoScrollMove)) : (Be.add(t, "mousedown", Je.selectorDown), Be.add(t, "mousemove", Je.pointerMove), Be.add(t, "mouseup", Je.pointerUp), Be.add(t, "mouseover", Je.pointerOver), Be.add(t, "mouseout", Je.pointerOut), Be.add(t, "touchstart", Je.selectorDown), Be.add(t, "touchmove", Je.pointerMove), Be.add(t, "touchend", Je.pointerUp), Be.add(t, "touchcancel", Je.pointerCancel), Be.add(t, "mousemove", Je.autoScrollMove), Be.add(t, "touchmove", Je.autoScrollMove)), Be.add(e, "blur", he);
            try {
                if (e.frameElement) {
                    var r = e.frameElement.ownerDocument, s = r.defaultView;
                    Be.add(r, "mouseup", Je.pointerEnd), Be.add(r, "touchend", Je.pointerEnd), Be.add(r, "touchcancel", Je.pointerEnd), Be.add(r, "pointerup", Je.pointerEnd), Be.add(r, "MSPointerUp", Je.pointerEnd), Be.add(s, "blur", he)
                }
            } catch (n) {
                ne.windowParentError = n
            }
            Be.add(t, "dragstart", function (t) {
                for (var e = 0; e < Me.length; e++) {
                    var i = Me[e];
                    if (i.element && (i.element === t.target || R(i.element, t.target))) return void i.checkAndPreventDefault(t, i.target, i.element)
                }
            }), Be.useAttachEvent && (Be.add(t, "selectstart", function (t) {
                var e = Me[0];
                e.currentAction() && e.checkAndPreventDefault(t)
            }), Be.add(t, "dblclick", K("ie8Dblclick"))), Te.push(t)
        }
    }

    function le(t, e) {
        for (var i = 0, r = t.length; r > i; i++) if (t[i] === e) return i;
        return -1
    }

    function ce(t, e) {
        return -1 !== le(t, e)
    }

    function de(e, i, r) {
        return ve ? ve(e, i, r) : (me !== t && (i = i.replace(/\/deep\//g, " ")), e[Ge](i))
    }

    function ue(t, e, r) {
        for (; i(t);) {
            if (de(t, e)) return !0;
            if (t = F(t), t === r) return de(t, e)
        }
        return !1
    }

    if (t) {
        var ge, ve, me = function () {
                var e = t.document.createTextNode("");
                return e.ownerDocument !== t.document && "function" == typeof t.wrap && t.wrap(e) === e ? t.wrap(t) : t
            }(), fe = me.document, ye = me.DocumentFragment || e, xe = me.SVGElement || e, Ee = me.SVGSVGElement || e,
            Se = me.SVGElementInstance || e, be = me.HTMLElement || me.Element,
            we = me.PointerEvent || me.MSPointerEvent, ze = Math.hypot || function (t, e) {
                return Math.sqrt(t * t + e * e)
            }, De = {}, Te = [], Ce = [], Me = [], Pe = !1, Ae = {}, Oe = {
                base: {
                    accept: null,
                    actionChecker: null,
                    styleCursor: !0,
                    preventDefault: "auto",
                    origin: {x: 0, y: 0},
                    deltaSource: "page",
                    allowFrom: null,
                    ignoreFrom: null,
                    _context: fe,
                    dropChecker: null
                },
                drag: {
                    enabled: !1,
                    manualStart: !0,
                    max: 1 / 0,
                    maxPerElement: 1,
                    snap: null,
                    restrict: null,
                    inertia: null,
                    autoScroll: null,
                    axis: "xy"
                },
                drop: {enabled: !1, accept: null, overlap: "pointer"},
                resize: {
                    enabled: !1,
                    manualStart: !1,
                    max: 1 / 0,
                    maxPerElement: 1,
                    snap: null,
                    restrict: null,
                    inertia: null,
                    autoScroll: null,
                    square: !1,
                    preserveAspectRatio: !1,
                    axis: "xy",
                    margin: 0 / 0,
                    edges: null,
                    invert: "none"
                },
                gesture: {manualStart: !1, enabled: !1, max: 1 / 0, maxPerElement: 1, restrict: null},
                perAction: {
                    manualStart: !1,
                    max: 1 / 0,
                    maxPerElement: 1,
                    snap: {enabled: !1, endOnly: !1, range: 1 / 0, targets: null, offsets: null, relativePoints: null},
                    restrict: {enabled: !1, endOnly: !1},
                    autoScroll: {enabled: !1, container: null, margin: 60, speed: 300},
                    inertia: {
                        enabled: !1,
                        resistance: 10,
                        minSpeed: 100,
                        endSpeed: 10,
                        allowResume: !0,
                        zeroResumeDelta: !0,
                        smoothEndDuration: 300
                    }
                },
                _holdDuration: 600
            }, _e = {
                interaction: null, i: null, x: 0, y: 0, scroll: function () {
                    var t, e, i, s, n = _e.interaction.target.options[_e.interaction.prepared.name].autoScroll,
                        o = n.container || z(_e.interaction.element), a = (new Date).getTime(),
                        h = (a - _e.prevTimeX) / 1e3, p = (a - _e.prevTimeY) / 1e3;
                    n.velocity ? (t = n.velocity.x, e = n.velocity.y) : t = e = n.speed, i = t * h, s = e * p, (i >= 1 || s >= 1) && (r(o) ? o.scrollBy(_e.x * i, _e.y * s) : o && (o.scrollLeft += _e.x * i, o.scrollTop += _e.y * s), i >= 1 && (_e.prevTimeX = a), s >= 1 && (_e.prevTimeY = a)), _e.isScrolling && (je(_e.i), _e.i = Le(_e.scroll))
                }, isScrolling: !1, prevTimeX: 0, prevTimeY: 0, start: function (t) {
                    _e.isScrolling = !0, je(_e.i), _e.interaction = t, _e.prevTimeX = (new Date).getTime(), _e.prevTimeY = (new Date).getTime(), _e.i = Le(_e.scroll)
                }, stop: function () {
                    _e.isScrolling = !1, je(_e.i)
                }
            }, ke = "ontouchstart" in me || me.DocumentTouch && fe instanceof me.DocumentTouch, Xe = !!we,
            Ye = ke || Xe ? 20 : 10, Re = 1, Ie = 0, Fe = 1 / 0, qe = fe.all && !me.atob ? {
                drag: "move",
                resizex: "e-resize",
                resizey: "s-resize",
                resizexy: "se-resize",
                resizetop: "n-resize",
                resizeleft: "w-resize",
                resizebottom: "s-resize",
                resizeright: "e-resize",
                resizetopleft: "se-resize",
                resizebottomright: "se-resize",
                resizetopright: "ne-resize",
                resizebottomleft: "ne-resize",
                gesture: ""
            } : {
                drag: "move",
                resizex: "ew-resize",
                resizey: "ns-resize",
                resizexy: "nwse-resize",
                resizetop: "ns-resize",
                resizeleft: "ew-resize",
                resizebottom: "ns-resize",
                resizeright: "ew-resize",
                resizetopleft: "nwse-resize",
                resizebottomright: "nwse-resize",
                resizetopright: "nesw-resize",
                resizebottomleft: "nesw-resize",
                gesture: ""
            }, Ne = {drag: !0, resize: !0, gesture: !0}, He = "onmousewheel" in fe ? "mousewheel" : "wheel",
            We = ["dragstart", "dragmove", "draginertiastart", "dragend", "dragenter", "dragleave", "dropactivate", "dropdeactivate", "dropmove", "drop", "resizestart", "resizemove", "resizeinertiastart", "resizeend", "gesturestart", "gesturemove", "gestureinertiastart", "gestureend", "down", "move", "up", "cancel", "tap", "doubletap", "hold"],
            Ue = {}, Ve = "Opera" == navigator.appName && ke && navigator.userAgent.match("Presto"),
            $e = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion),
            Ge = "matches" in Element.prototype ? "matches" : "webkitMatchesSelector" in Element.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in Element.prototype ? "mozMatchesSelector" : "oMatchesSelector" in Element.prototype ? "oMatchesSelector" : "msMatchesSelector",
            Le = t.requestAnimationFrame, je = t.cancelAnimationFrame, Be = function () {
                function t(t, e, a, d) {
                    var u = le(p, t), g = l[u];
                    if (g || (g = {events: {}, typeCount: 0}, u = p.push(t) - 1, l.push(g), c.push(n ? {
                            supplied: [],
                            wrapped: [],
                            useCount: []
                        } : null)), g.events[e] || (g.events[e] = [], g.typeCount++), !ce(g.events[e], a)) {
                        var v;
                        if (n) {
                            var m = c[u], f = le(m.supplied, a), y = m.wrapped[f] || function (e) {
                                e.immediatePropagationStopped || (e.target = e.srcElement, e.currentTarget = t, e.preventDefault = e.preventDefault || i, e.stopPropagation = e.stopPropagation || r, e.stopImmediatePropagation = e.stopImmediatePropagation || s, /mouse|click/.test(e.type) && (e.pageX = e.clientX + z(t).document.documentElement.scrollLeft, e.pageY = e.clientY + z(t).document.documentElement.scrollTop), a(e))
                            };
                            v = t[o](h + e, y, Boolean(d)), -1 === f ? (m.supplied.push(a), m.wrapped.push(y), m.useCount.push(1)) : m.useCount[f]++
                        } else v = t[o](e, a, d || !1);
                        return g.events[e].push(a), v
                    }
                }

                function e(t, i, r, s) {
                    var o, d, u, g = le(p, t), v = l[g], m = r;
                    if (v && v.events) if (n && (d = c[g], u = le(d.supplied, r), m = d.wrapped[u]), "all" !== i) {
                        if (v.events[i]) {
                            var f = v.events[i].length;
                            if ("all" === r) {
                                for (o = 0; f > o; o++) e(t, i, v.events[i][o], Boolean(s));
                                return
                            }
                            for (o = 0; f > o; o++) if (v.events[i][o] === r) {
                                t[a](h + i, m, s || !1), v.events[i].splice(o, 1), n && d && (d.useCount[u]--, 0 === d.useCount[u] && (d.supplied.splice(u, 1), d.wrapped.splice(u, 1), d.useCount.splice(u, 1)));
                                break
                            }
                            v.events[i] && 0 === v.events[i].length && (v.events[i] = null, v.typeCount--)
                        }
                        v.typeCount || (l.splice(g, 1), p.splice(g, 1), c.splice(g, 1))
                    } else for (i in v.events) v.events.hasOwnProperty(i) && e(t, i, "all")
                }

                function i() {
                    this.returnValue = !1
                }

                function r() {
                    this.cancelBubble = !0
                }

                function s() {
                    this.cancelBubble = !0, this.immediatePropagationStopped = !0
                }

                var n = "attachEvent" in me && !("addEventListener" in me), o = n ? "attachEvent" : "addEventListener",
                    a = n ? "detachEvent" : "removeEventListener", h = n ? "on" : "", p = [], l = [], c = [];
                return {add: t, remove: e, useAttachEvent: n, _elements: p, _targets: l, _attachedListeners: c}
            }(), Ke = {webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/};
        j.prototype = {
            getPageXY: function (t, e) {
                return x(t, e, this)
            }, getClientXY: function (t, e) {
                return E(t, e, this)
            }, setEventXY: function (t, e) {
                return v(t, e, this)
            }, pointerOver: function (t, e, i) {
                function r(t, e) {
                    t && q(t, i) && !N(t, i, i) && H(t, i, i) && de(i, e) && (s.push(t), n.push(i))
                }

                if (!this.prepared.name && this.mouse) {
                    var s = [], n = [], o = this.element;
                    this.addPointer(t), !this.target || !N(this.target, this.element, i) && H(this.target, this.element, i) || (this.target = null, this.element = null, this.matches = [], this.matchElements = []);
                    var a = Ce.get(i), h = a && !N(a, i, i) && H(a, i, i) && ie(a.getAction(t, e, this, i), a);
                    h && !G(a, i, h) && (h = null), h ? (this.target = a, this.element = i, this.matches = [], this.matchElements = []) : (Ce.forEachSelector(r), this.validateSelector(t, e, s, n) ? (this.matches = s, this.matchElements = n, this.pointerHover(t, e, this.matches, this.matchElements), Be.add(i, we ? ge.move : "mousemove", Je.pointerHover)) : this.target && (R(o, i) ? (this.pointerHover(t, e, this.matches, this.matchElements), Be.add(this.element, we ? ge.move : "mousemove", Je.pointerHover)) : (this.target = null, this.element = null, this.matches = [], this.matchElements = [])))
                }
            }, pointerHover: function (t, e, i, r, s, n) {
                var o = this.target;
                if (!this.prepared.name && this.mouse) {
                    var a;
                    this.setEventXY(this.curCoords, [t]), s ? a = this.validateSelector(t, e, s, n) : o && (a = ie(o.getAction(this.pointers[0], e, this, this.element), this.target)), o && o.options.styleCursor && (o._doc.documentElement.style.cursor = a ? Z(a) : "")
                } else this.prepared.name && this.checkAndPreventDefault(e, o, this.element)
            }, pointerOut: function (t, e, i) {
                this.prepared.name || (Ce.get(i) || Be.remove(i, we ? ge.move : "mousemove", Je.pointerHover), this.target && this.target.options.styleCursor && !this.interacting() && (this.target._doc.documentElement.style.cursor = ""))
            }, selectorDown: function (t, e, r, s) {
                function n(t, e, i) {
                    var s = ve ? i.querySelectorAll(e) : void 0;
                    q(t, p) && !N(t, p, r) && H(t, p, r) && de(p, e, s) && (a.matches.push(t), a.matchElements.push(p))
                }

                var o, a = this, h = Be.useAttachEvent ? d({}, e) : e, p = r, l = this.addPointer(t);
                if (this.holdTimers[l] = setTimeout(function () {
                        a.pointerHold(Be.useAttachEvent ? h : t, h, r, s)
                    }, Oe._holdDuration), this.pointerIsDown = !0, this.inertiaStatus.active && this.target.selector) for (; i(p);) {
                    if (p === this.element && ie(this.target.getAction(t, e, this, this.element), this.target).name === this.prepared.name) return je(this.inertiaStatus.i), this.inertiaStatus.active = !1, void this.collectEventTargets(t, e, r, "down");
                    p = F(p)
                }
                if (this.interacting()) return void this.collectEventTargets(t, e, r, "down");
                for (this.setEventXY(this.curCoords, [t]), this.downEvent = e; i(p) && !o;) this.matches = [], this.matchElements = [], Ce.forEachSelector(n), o = this.validateSelector(t, e, this.matches, this.matchElements), p = F(p);
                return o ? (this.prepared.name = o.name, this.prepared.axis = o.axis, this.prepared.edges = o.edges, this.collectEventTargets(t, e, r, "down"), this.pointerDown(t, e, r, s, o)) : (this.downTimes[l] = (new Date).getTime(), this.downTargets[l] = r, u(this.downPointer, t), g(this.prevCoords, this.curCoords), this.pointerWasMoved = !1, void this.collectEventTargets(t, e, r, "down"))
            }, pointerDown: function (t, e, i, r, s) {
                if (!s && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) return void this.checkAndPreventDefault(e, this.target, this.element);
                this.pointerIsDown = !0, this.downEvent = e;
                var n, o = this.addPointer(t);
                if (this.pointerIds.length > 1 && this.target._element === this.element) {
                    var a = ie(s || this.target.getAction(t, e, this, this.element), this.target);
                    G(this.target, this.element, a) && (n = a), this.prepared.name = null
                } else if (!this.prepared.name) {
                    var h = Ce.get(r);
                    h && !N(h, r, i) && H(h, r, i) && (n = ie(s || h.getAction(t, e, this, r), h, i)) && G(h, r, n) && (this.target = h, this.element = r)
                }
                var p = this.target, l = p && p.options;
                if (!p || !s && this.prepared.name) this.inertiaStatus.active && r === this.element && ie(p.getAction(t, e, this, this.element), p).name === this.prepared.name && (je(this.inertiaStatus.i), this.inertiaStatus.active = !1, this.checkAndPreventDefault(e, p, this.element)); else {
                    if (n = n || ie(s || p.getAction(t, e, this, r), p, this.element), this.setEventXY(this.startCoords, this.pointers), !n) return;
                    l.styleCursor && (p._doc.documentElement.style.cursor = Z(n)), this.resizeAxes = "resize" === n.name ? n.axis : null, "gesture" === n && this.pointerIds.length < 2 && (n = null), this.prepared.name = n.name, this.prepared.axis = n.axis, this.prepared.edges = n.edges, this.snapStatus.snappedX = this.snapStatus.snappedY = this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = 0 / 0, this.downTimes[o] = (new Date).getTime(), this.downTargets[o] = i, u(this.downPointer, t), g(this.prevCoords, this.startCoords), this.pointerWasMoved = !1, this.checkAndPreventDefault(e, p, this.element)
                }
            }, setModifications: function (t, e) {
                var i = this.target, r = !0,
                    s = U(i, this.prepared.name) && (!i.options[this.prepared.name].snap.endOnly || e),
                    n = V(i, this.prepared.name) && (!i.options[this.prepared.name].restrict.endOnly || e);
                return s ? this.setSnapping(t) : this.snapStatus.locked = !1, n ? this.setRestriction(t) : this.restrictStatus.restricted = !1, s && this.snapStatus.locked && !this.snapStatus.changed ? r = n && this.restrictStatus.restricted && this.restrictStatus.changed : n && this.restrictStatus.restricted && !this.restrictStatus.changed && (r = !1), r
            }, setStartOffsets: function (t, e, i) {
                var r, s, n = e.getRect(i), o = _(e, i), a = e.options[this.prepared.name].snap,
                    h = e.options[this.prepared.name].restrict;
                n ? (this.startOffset.left = this.startCoords.page.x - n.left, this.startOffset.top = this.startCoords.page.y - n.top, this.startOffset.right = n.right - this.startCoords.page.x, this.startOffset.bottom = n.bottom - this.startCoords.page.y, r = "width" in n ? n.width : n.right - n.left, s = "height" in n ? n.height : n.bottom - n.top) : this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0, this.snapOffsets.splice(0);
                var p = a && "startCoords" === a.offset ? {
                    x: this.startCoords.page.x - o.x,
                    y: this.startCoords.page.y - o.y
                } : a && a.offset || {x: 0, y: 0};
                if (n && a && a.relativePoints && a.relativePoints.length) for (var l = 0; l < a.relativePoints.length; l++) this.snapOffsets.push({
                    x: this.startOffset.left - r * a.relativePoints[l].x + p.x,
                    y: this.startOffset.top - s * a.relativePoints[l].y + p.y
                }); else this.snapOffsets.push(p);
                n && h.elementRect ? (this.restrictOffset.left = this.startOffset.left - r * h.elementRect.left, this.restrictOffset.top = this.startOffset.top - s * h.elementRect.top, this.restrictOffset.right = this.startOffset.right - r * (1 - h.elementRect.right), this.restrictOffset.bottom = this.startOffset.bottom - s * (1 - h.elementRect.bottom)) : this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0
            }, start: function (t, e, i) {
                this.interacting() || !this.pointerIsDown || this.pointerIds.length < ("gesture" === t.name ? 2 : 1) || (-1 === le(Me, this) && Me.push(this), this.prepared.name || this.setEventXY(this.startCoords), this.prepared.name = t.name, this.prepared.axis = t.axis, this.prepared.edges = t.edges, this.target = e, this.element = i, this.setStartOffsets(t.name, e, i), this.setModifications(this.startCoords.page), this.prevEvent = this[this.prepared.name + "Start"](this.downEvent))
            }, pointerMove: function (t, e, r, s, n) {
                if (this.inertiaStatus.active) {
                    var o = this.inertiaStatus.upCoords.page, a = this.inertiaStatus.upCoords.client, h = {
                        pageX: o.x + this.inertiaStatus.sx,
                        pageY: o.y + this.inertiaStatus.sy,
                        clientX: a.x + this.inertiaStatus.sx,
                        clientY: a.y + this.inertiaStatus.sy
                    };
                    this.setEventXY(this.curCoords, [h])
                } else this.recordPointer(t), this.setEventXY(this.curCoords, this.pointers);
                var p, l,
                    c = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y,
                    d = this.mouse ? 0 : le(this.pointerIds, b(t));
                if (this.pointerIsDown && !this.pointerWasMoved && (p = this.curCoords.client.x - this.startCoords.client.x, l = this.curCoords.client.y - this.startCoords.client.y, this.pointerWasMoved = ze(p, l) > Re), c || this.pointerIsDown && !this.pointerWasMoved || (this.pointerIsDown && clearTimeout(this.holdTimers[d]), this.collectEventTargets(t, e, r, "move")), this.pointerIsDown) {
                    if (c && this.pointerWasMoved && !n) return void this.checkAndPreventDefault(e, this.target, this.element);
                    if (m(this.pointerDelta, this.prevCoords, this.curCoords), this.prepared.name) {
                        if (this.pointerWasMoved && (!this.inertiaStatus.active || t instanceof J && /inertiastart/.test(t.type))) {
                            if (!this.interacting() && (m(this.pointerDelta, this.prevCoords, this.curCoords), "drag" === this.prepared.name)) {
                                var u = Math.abs(p), v = Math.abs(l), f = this.target.options.drag.axis,
                                    y = u > v ? "x" : v > u ? "y" : "xy";
                                if ("xy" !== y && "xy" !== f && f !== y) {
                                    this.prepared.name = null;
                                    for (var x = r; i(x);) {
                                        var E = Ce.get(x);
                                        if (E && E !== this.target && !E.options.drag.manualStart && "drag" === E.getAction(this.downPointer, this.downEvent, this, x).name && W(y, E)) {
                                            this.prepared.name = "drag", this.target = E, this.element = x;
                                            break
                                        }
                                        x = F(x)
                                    }
                                    if (!this.prepared.name) {
                                        var S = this, w = function (t, e, i) {
                                            var s = ve ? i.querySelectorAll(e) : void 0;
                                            if (t !== S.target) return q(t, r) && !t.options.drag.manualStart && !N(t, x, r) && H(t, x, r) && de(x, e, s) && "drag" === t.getAction(S.downPointer, S.downEvent, S, x).name && W(y, t) && G(t, x, "drag") ? t : void 0
                                        };
                                        for (x = r; i(x);) {
                                            var z = Ce.forEachSelector(w);
                                            if (z) {
                                                this.prepared.name = "drag", this.target = z, this.element = x;
                                                break
                                            }
                                            x = F(x)
                                        }
                                    }
                                }
                            }
                            var D = !!this.prepared.name && !this.interacting();
                            if (D && (this.target.options[this.prepared.name].manualStart || !G(this.target, this.element, this.prepared))) return void this.stop(e);
                            if (this.prepared.name && this.target) {
                                D && this.start(this.prepared, this.target, this.element);
                                var T = this.setModifications(this.curCoords.page, n);
                                (T || D) && (this.prevEvent = this[this.prepared.name + "Move"](e)), this.checkAndPreventDefault(e, this.target, this.element)
                            }
                        }
                        g(this.prevCoords, this.curCoords), (this.dragging || this.resizing) && this.autoScrollMove(t)
                    }
                }
            }, dragStart: function (t) {
                var e = new J(this, t, "drag", "start", this.element);
                this.dragging = !0, this.target.fire(e), this.activeDrops.dropzones = [], this.activeDrops.elements = [], this.activeDrops.rects = [], this.dynamicDrop || this.setActiveDrops(this.element);
                var i = this.getDropEvents(t, e);
                return i.activate && this.fireActiveDrops(i.activate), e
            }, dragMove: function (t) {
                var e = this.target, i = new J(this, t, "drag", "move", this.element), r = this.element,
                    s = this.getDrop(i, t, r);
                this.dropTarget = s.dropzone, this.dropElement = s.element;
                var n = this.getDropEvents(t, i);
                return e.fire(i), n.leave && this.prevDropTarget.fire(n.leave), n.enter && this.dropTarget.fire(n.enter), n.move && this.dropTarget.fire(n.move), this.prevDropTarget = this.dropTarget, this.prevDropElement = this.dropElement, i
            }, resizeStart: function (t) {
                var e = new J(this, t, "resize", "start", this.element);
                if (this.prepared.edges) {
                    var i = this.target.getRect(this.element);
                    if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {
                        var r = d({}, this.prepared.edges);
                        r.top = r.top || r.left && !r.bottom, r.left = r.left || r.top && !r.right, r.bottom = r.bottom || r.right && !r.top, r.right = r.right || r.bottom && !r.left, this.prepared._linkedEdges = r
                    } else this.prepared._linkedEdges = null;
                    this.target.options.resize.preserveAspectRatio && (this.resizeStartAspectRatio = i.width / i.height), this.resizeRects = {
                        start: i,
                        current: d({}, i),
                        restricted: d({}, i),
                        previous: d({}, i),
                        delta: {left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0}
                    }, e.rect = this.resizeRects.restricted, e.deltaRect = this.resizeRects.delta
                }
                return this.target.fire(e), this.resizing = !0, e
            }, resizeMove: function (t) {
                var e = new J(this, t, "resize", "move", this.element), i = this.prepared.edges,
                    r = this.target.options.resize.invert, s = "reposition" === r || "negate" === r;
                if (i) {
                    var n = e.dx, o = e.dy, a = this.resizeRects.start, h = this.resizeRects.current,
                        p = this.resizeRects.restricted, l = this.resizeRects.delta,
                        c = d(this.resizeRects.previous, p), u = i;
                    if (this.target.options.resize.preserveAspectRatio) {
                        var g = this.resizeStartAspectRatio;
                        i = this.prepared._linkedEdges, u.left && u.bottom || u.right && u.top ? o = -n / g : u.left || u.right ? o = n / g : (u.top || u.bottom) && (n = o * g)
                    } else this.target.options.resize.square && (i = this.prepared._linkedEdges, u.left && u.bottom || u.right && u.top ? o = -n : u.left || u.right ? o = n : (u.top || u.bottom) && (n = o));
                    if (i.top && (h.top += o), i.bottom && (h.bottom += o), i.left && (h.left += n), i.right && (h.right += n), s) {
                        if (d(p, h), "reposition" === r) {
                            var v;
                            p.top > p.bottom && (v = p.top, p.top = p.bottom, p.bottom = v), p.left > p.right && (v = p.left, p.left = p.right, p.right = v)
                        }
                    } else p.top = Math.min(h.top, a.bottom), p.bottom = Math.max(h.bottom, a.top), p.left = Math.min(h.left, a.right), p.right = Math.max(h.right, a.left);
                    p.width = p.right - p.left, p.height = p.bottom - p.top;
                    for (var m in p) l[m] = p[m] - c[m];
                    e.edges = this.prepared.edges, e.rect = p, e.deltaRect = l
                }
                return this.target.fire(e), e
            }, gestureStart: function (t) {
                var e = new J(this, t, "gesture", "start", this.element);
                return e.ds = 0, this.gesture.startDistance = this.gesture.prevDistance = e.distance, this.gesture.startAngle = this.gesture.prevAngle = e.angle, this.gesture.scale = 1, this.gesturing = !0, this.target.fire(e), e
            }, gestureMove: function (t) {
                if (!this.pointerIds.length) return this.prevEvent;
                var e;
                return e = new J(this, t, "gesture", "move", this.element), e.ds = e.scale - this.gesture.scale, this.target.fire(e), this.gesture.prevAngle = e.angle, this.gesture.prevDistance = e.distance, 1 / 0 === e.scale || null === e.scale || void 0 === e.scale || isNaN(e.scale) || (this.gesture.scale = e.scale), e
            }, pointerHold: function (t, e, i) {
                this.collectEventTargets(t, e, i, "hold")
            }, pointerUp: function (t, e, i, r) {
                var s = this.mouse ? 0 : le(this.pointerIds, b(t));
                clearTimeout(this.holdTimers[s]), this.collectEventTargets(t, e, i, "up"), this.collectEventTargets(t, e, i, "tap"), this.pointerEnd(t, e, i, r), this.removePointer(t)
            }, pointerCancel: function (t, e, i, r) {
                var s = this.mouse ? 0 : le(this.pointerIds, b(t));
                clearTimeout(this.holdTimers[s]), this.collectEventTargets(t, e, i, "cancel"), this.pointerEnd(t, e, i, r), this.removePointer(t)
            }, ie8Dblclick: function (t, e, i) {
                this.prevTap && e.clientX === this.prevTap.clientX && e.clientY === this.prevTap.clientY && i === this.prevTap.target && (this.downTargets[0] = i, this.downTimes[0] = (new Date).getTime(), this.collectEventTargets(t, e, i, "tap"))
            }, pointerEnd: function (t, e, i, r) {
                var s, n = this.target, o = n && n.options,
                    a = o && this.prepared.name && o[this.prepared.name].inertia, h = this.inertiaStatus;
                if (this.interacting()) {
                    if (h.active && !h.ending) return;
                    var p, l, c = (new Date).getTime(), u = !1, v = !1, m = !1,
                        f = U(n, this.prepared.name) && o[this.prepared.name].snap.endOnly,
                        y = V(n, this.prepared.name) && o[this.prepared.name].restrict.endOnly, x = 0, E = 0;
                    if (p = this.dragging ? "x" === o.drag.axis ? Math.abs(this.pointerDelta.client.vx) : "y" === o.drag.axis ? Math.abs(this.pointerDelta.client.vy) : this.pointerDelta.client.speed : this.pointerDelta.client.speed, u = a && a.enabled && "gesture" !== this.prepared.name && e !== h.startEvent, v = u && c - this.curCoords.timeStamp < 50 && p > a.minSpeed && p > a.endSpeed, u && !v && (f || y)) {
                        var S = {};
                        S.snap = S.restrict = S, f && (this.setSnapping(this.curCoords.page, S), S.locked && (x += S.dx, E += S.dy)), y && (this.setRestriction(this.curCoords.page, S), S.restricted && (x += S.dx, E += S.dy)), (x || E) && (m = !0)
                    }
                    if (v || m) {
                        if (g(h.upCoords, this.curCoords), this.pointers[0] = h.startEvent = l = new J(this, e, this.prepared.name, "inertiastart", this.element), h.t0 = c, n.fire(h.startEvent), v) {
                            h.vx0 = this.pointerDelta.client.vx, h.vy0 = this.pointerDelta.client.vy, h.v0 = p, this.calcInertia(h);
                            var b, w = d({}, this.curCoords.page), z = _(n, this.element);
                            if (w.x = w.x + h.xe - z.x, w.y = w.y + h.ye - z.y, b = {
                                    useStatusXY: !0,
                                    x: w.x,
                                    y: w.y,
                                    dx: 0,
                                    dy: 0,
                                    snap: null
                                }, b.snap = b, x = E = 0, f) {
                                var D = this.setSnapping(this.curCoords.page, b);
                                D.locked && (x += D.dx, E += D.dy)
                            }
                            if (y) {
                                var T = this.setRestriction(this.curCoords.page, b);
                                T.restricted && (x += T.dx, E += T.dy)
                            }
                            h.modifiedXe += x, h.modifiedYe += E, h.i = Le(this.boundInertiaFrame)
                        } else h.smoothEnd = !0, h.xe = x, h.ye = E, h.sx = h.sy = 0, h.i = Le(this.boundSmoothEndFrame);
                        return void(h.active = !0)
                    }
                    (f || y) && this.pointerMove(t, e, i, r, !0)
                }
                if (this.dragging) {
                    s = new J(this, e, "drag", "end", this.element);
                    var C = this.element, M = this.getDrop(s, e, C);
                    this.dropTarget = M.dropzone, this.dropElement = M.element;
                    var P = this.getDropEvents(e, s);
                    P.leave && this.prevDropTarget.fire(P.leave), P.enter && this.dropTarget.fire(P.enter), P.drop && this.dropTarget.fire(P.drop), P.deactivate && this.fireActiveDrops(P.deactivate), n.fire(s)
                } else this.resizing ? (s = new J(this, e, "resize", "end", this.element), n.fire(s)) : this.gesturing && (s = new J(this, e, "gesture", "end", this.element), n.fire(s));
                this.stop(e)
            }, collectDrops: function (t) {
                var e, r = [], s = [];
                for (t = t || this.element, e = 0; e < Ce.length; e++) if (Ce[e].options.drop.enabled) {
                    var n = Ce[e], o = n.options.drop.accept;
                    if (!(i(o) && o !== t || l(o) && !de(t, o))) for (var a = n.selector ? n._context.querySelectorAll(n.selector) : [n._element], h = 0, p = a.length; p > h; h++) {
                        var c = a[h];
                        c !== t && (r.push(n), s.push(c))
                    }
                }
                return {dropzones: r, elements: s}
            }, fireActiveDrops: function (t) {
                var e, i, r, s;
                for (e = 0; e < this.activeDrops.dropzones.length; e++) i = this.activeDrops.dropzones[e], r = this.activeDrops.elements[e], r !== s && (t.target = r, i.fire(t)), s = r
            }, setActiveDrops: function (t) {
                var e = this.collectDrops(t, !0);
                this.activeDrops.dropzones = e.dropzones, this.activeDrops.elements = e.elements, this.activeDrops.rects = [];
                for (var i = 0; i < this.activeDrops.dropzones.length; i++) this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i])
            }, getDrop: function (t, e, i) {
                var r = [];
                Pe && this.setActiveDrops(i);
                for (var s = 0; s < this.activeDrops.dropzones.length; s++) {
                    var n = this.activeDrops.dropzones[s], o = this.activeDrops.elements[s],
                        a = this.activeDrops.rects[s];
                    r.push(n.dropCheck(t, e, this.target, i, o, a) ? o : null)
                }
                var h = L(r), p = this.activeDrops.dropzones[h] || null, l = this.activeDrops.elements[h] || null;
                return {dropzone: p, element: l}
            }, getDropEvents: function (t, e) {
                var i = {enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null};
                return this.dropElement !== this.prevDropElement && (this.prevDropTarget && (i.leave = {
                    target: this.prevDropElement,
                    dropzone: this.prevDropTarget,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    timeStamp: e.timeStamp,
                    type: "dragleave"
                }, e.dragLeave = this.prevDropElement, e.prevDropzone = this.prevDropTarget), this.dropTarget && (i.enter = {
                    target: this.dropElement,
                    dropzone: this.dropTarget,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    timeStamp: e.timeStamp,
                    type: "dragenter"
                }, e.dragEnter = this.dropElement, e.dropzone = this.dropTarget)), "dragend" === e.type && this.dropTarget && (i.drop = {
                    target: this.dropElement,
                    dropzone: this.dropTarget,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    timeStamp: e.timeStamp,
                    type: "drop"
                }, e.dropzone = this.dropTarget), "dragstart" === e.type && (i.activate = {
                    target: null,
                    dropzone: null,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    timeStamp: e.timeStamp,
                    type: "dropactivate"
                }), "dragend" === e.type && (i.deactivate = {
                    target: null,
                    dropzone: null,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    timeStamp: e.timeStamp,
                    type: "dropdeactivate"
                }), "dragmove" === e.type && this.dropTarget && (i.move = {
                    target: this.dropElement,
                    dropzone: this.dropTarget,
                    relatedTarget: e.target,
                    draggable: e.interactable,
                    dragEvent: e,
                    interaction: this,
                    dragmove: e,
                    timeStamp: e.timeStamp,
                    type: "dropmove"
                }, e.dropzone = this.dropTarget), i
            }, currentAction: function () {
                return this.dragging && "drag" || this.resizing && "resize" || this.gesturing && "gesture" || null
            }, interacting: function () {
                return this.dragging || this.resizing || this.gesturing
            }, clearTargets: function () {
                this.target = this.element = null, this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null
            }, stop: function (t) {
                if (this.interacting()) {
                    _e.stop(), this.matches = [], this.matchElements = [];
                    var e = this.target;
                    e.options.styleCursor && (e._doc.documentElement.style.cursor = ""), t && a(t.preventDefault) && this.checkAndPreventDefault(t, e, this.element), this.dragging && (this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null)
                }
                this.clearTargets(), this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = !1, this.prepared.name = this.prevEvent = null, this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;
                for (var i = 0; i < this.pointers.length; i++) -1 === le(this.pointerIds, b(this.pointers[i])) && this.pointers.splice(i, 1)
            }, inertiaFrame: function () {
                var t = this.inertiaStatus, e = this.target.options[this.prepared.name].inertia, i = e.resistance,
                    r = (new Date).getTime() / 1e3 - t.t0;
                if (r < t.te) {
                    var s = 1 - (Math.exp(-i * r) - t.lambda_v0) / t.one_ve_v0;
                    if (t.modifiedXe === t.xe && t.modifiedYe === t.ye) t.sx = t.xe * s, t.sy = t.ye * s; else {
                        var n = X(0, 0, t.xe, t.ye, t.modifiedXe, t.modifiedYe, s);
                        t.sx = n.x, t.sy = n.y
                    }
                    this.pointerMove(t.startEvent, t.startEvent), t.i = Le(this.boundInertiaFrame)
                } else t.ending = !0, t.sx = t.modifiedXe, t.sy = t.modifiedYe, this.pointerMove(t.startEvent, t.startEvent), this.pointerEnd(t.startEvent, t.startEvent), t.active = t.ending = !1
            }, smoothEndFrame: function () {
                var t = this.inertiaStatus, e = (new Date).getTime() - t.t0,
                    i = this.target.options[this.prepared.name].inertia.smoothEndDuration;
                i > e ? (t.sx = Y(e, 0, t.xe, i), t.sy = Y(e, 0, t.ye, i), this.pointerMove(t.startEvent, t.startEvent), t.i = Le(this.boundSmoothEndFrame)) : (t.ending = !0, t.sx = t.xe, t.sy = t.ye, this.pointerMove(t.startEvent, t.startEvent), this.pointerEnd(t.startEvent, t.startEvent), t.smoothEnd = t.active = t.ending = !1)
            }, addPointer: function (t) {
                var e = b(t), i = this.mouse ? 0 : le(this.pointerIds, e);
                return -1 === i && (i = this.pointerIds.length), this.pointerIds[i] = e, this.pointers[i] = t, i
            }, removePointer: function (t) {
                var e = b(t), i = this.mouse ? 0 : le(this.pointerIds, e);
                -1 !== i && (this.pointers.splice(i, 1), this.pointerIds.splice(i, 1), this.downTargets.splice(i, 1), this.downTimes.splice(i, 1), this.holdTimers.splice(i, 1))
            }, recordPointer: function (t) {
                var e = this.mouse ? 0 : le(this.pointerIds, b(t));
                -1 !== e && (this.pointers[e] = t)
            }, collectEventTargets: function (t, e, r, s) {
                function n(t, e, n) {
                    var o = ve ? n.querySelectorAll(e) : void 0;
                    t._iEvents[s] && i(p) && q(t, p) && !N(t, p, r) && H(t, p, r) && de(p, e, o) && (a.push(t), h.push(p))
                }

                var o = this.mouse ? 0 : le(this.pointerIds, b(t));
                if ("tap" !== s || !this.pointerWasMoved && this.downTargets[o] && this.downTargets[o] === r) {
                    for (var a = [], h = [], p = r; p;) ne.isSet(p) && ne(p)._iEvents[s] && (a.push(ne(p)), h.push(p)), Ce.forEachSelector(n), p = F(p);
                    (a.length || "tap" === s) && this.firePointers(t, e, r, a, h, s)
                }
            }, firePointers: function (t, e, i, r, s, n) {
                var o, a, h, p = this.mouse ? 0 : le(this.pointerIds, b(t)), c = {};
                for ("doubletap" === n ? c = t : (u(c, e), e !== t && u(c, t), c.preventDefault = Q, c.stopPropagation = J.prototype.stopPropagation, c.stopImmediatePropagation = J.prototype.stopImmediatePropagation, c.interaction = this, c.timeStamp = (new Date).getTime(), c.originalEvent = e, c.originalPointer = t, c.type = n, c.pointerId = b(t), c.pointerType = this.mouse ? "mouse" : Xe ? l(t.pointerType) ? t.pointerType : [, , "touch", "pen", "mouse"][t.pointerType] : "touch"), "tap" === n && (c.dt = c.timeStamp - this.downTimes[p], a = c.timeStamp - this.tapTime, h = !!(this.prevTap && "doubletap" !== this.prevTap.type && this.prevTap.target === c.target && 500 > a), c.double = h, this.tapTime = c.timeStamp), o = 0; o < r.length && (c.currentTarget = s[o], c.interactable = r[o], r[o].fire(c), !(c.immediatePropagationStopped || c.propagationStopped && s[o + 1] !== c.currentTarget)); o++) ;
                if (h) {
                    var g = {};
                    d(g, c), g.dt = a, g.type = "doubletap", this.collectEventTargets(g, e, i, "doubletap"), this.prevTap = g
                } else "tap" === n && (this.prevTap = c)
            }, validateSelector: function (t, e, i, r) {
                for (var s = 0, n = i.length; n > s; s++) {
                    var o = i[s], a = r[s], h = ie(o.getAction(t, e, this, a), o);
                    if (h && G(o, a, h)) return this.target = o, this.element = a, h
                }
            }, setSnapping: function (t, e) {
                var i, r, s, n = this.target.options[this.prepared.name].snap, o = [];
                if (e = e || this.snapStatus, e.useStatusXY) r = {x: e.x, y: e.y}; else {
                    var p = _(this.target, this.element);
                    r = d({}, t), r.x -= p.x, r.y -= p.y
                }
                e.realX = r.x, e.realY = r.y, r.x = r.x - this.inertiaStatus.resumeDx, r.y = r.y - this.inertiaStatus.resumeDy;
                for (var l = n.targets ? n.targets.length : 0, c = 0; c < this.snapOffsets.length; c++) {
                    var u = {x: r.x - this.snapOffsets[c].x, y: r.y - this.snapOffsets[c].y};
                    for (s = 0; l > s; s++) i = a(n.targets[s]) ? n.targets[s](u.x, u.y, this) : n.targets[s], i && o.push({
                        x: h(i.x) ? i.x + this.snapOffsets[c].x : u.x,
                        y: h(i.y) ? i.y + this.snapOffsets[c].y : u.y,
                        range: h(i.range) ? i.range : n.range
                    })
                }
                var g = {target: null, inRange: !1, distance: 0, range: 0, dx: 0, dy: 0};
                for (s = 0, l = o.length; l > s; s++) {
                    i = o[s];
                    var v = i.range, m = i.x - r.x, f = i.y - r.y, y = ze(m, f), x = v >= y;
                    1 / 0 === v && g.inRange && 1 / 0 !== g.range && (x = !1), (!g.target || (x ? g.inRange && 1 / 0 !== v ? y / v < g.distance / g.range : 1 / 0 === v && 1 / 0 !== g.range || y < g.distance : !g.inRange && y < g.distance)) && (1 / 0 === v && (x = !0), g.target = i, g.distance = y, g.range = v, g.inRange = x, g.dx = m, g.dy = f, e.range = v)
                }
                var E;
                return g.target ? (E = e.snappedX !== g.target.x || e.snappedY !== g.target.y, e.snappedX = g.target.x, e.snappedY = g.target.y) : (E = !0, e.snappedX = 0 / 0, e.snappedY = 0 / 0), e.dx = g.dx, e.dy = g.dy, e.changed = E || g.inRange && !e.locked, e.locked = g.inRange, e
            }, setRestriction: function (t, e) {
                var r, s = this.target, n = s && s.options[this.prepared.name].restrict, o = n && n.restriction;
                if (!o) return e;
                e = e || this.restrictStatus, r = r = e.useStatusXY ? {
                    x: e.x,
                    y: e.y
                } : d({}, t), e.snap && e.snap.locked && (r.x += e.snap.dx || 0, r.y += e.snap.dy || 0), r.x -= this.inertiaStatus.resumeDx, r.y -= this.inertiaStatus.resumeDy, e.dx = 0, e.dy = 0, e.restricted = !1;
                var h, p, c;
                return l(o) && (o = "parent" === o ? F(this.element) : "self" === o ? s.getRect(this.element) : I(this.element, o), !o) ? e : (a(o) && (o = o(r.x, r.y, this.element)), i(o) && (o = T(o)), h = o, o ? "x" in o && "y" in o ? (p = Math.max(Math.min(h.x + h.width - this.restrictOffset.right, r.x), h.x + this.restrictOffset.left), c = Math.max(Math.min(h.y + h.height - this.restrictOffset.bottom, r.y), h.y + this.restrictOffset.top)) : (p = Math.max(Math.min(h.right - this.restrictOffset.right, r.x), h.left + this.restrictOffset.left), c = Math.max(Math.min(h.bottom - this.restrictOffset.bottom, r.y), h.top + this.restrictOffset.top)) : (p = r.x, c = r.y), e.dx = p - r.x, e.dy = c - r.y, e.changed = e.restrictedX !== p || e.restrictedY !== c, e.restricted = !(!e.dx && !e.dy), e.restrictedX = p, e.restrictedY = c, e)
            }, checkAndPreventDefault: function (t, e, i) {
                if (e = e || this.target) {
                    var r = e.options, s = r.preventDefault;
                    if ("auto" === s && i && !/^(input|select|textarea)$/i.test(t.target.nodeName)) {
                        if (/down|start/i.test(t.type) && "drag" === this.prepared.name && "xy" !== r.drag.axis) return;
                        if (r[this.prepared.name] && r[this.prepared.name].manualStart && !this.interacting()) return;
                        return void t.preventDefault()
                    }
                    return "always" === s ? void t.preventDefault() : void 0
                }
            }, calcInertia: function (t) {
                var e = this.target.options[this.prepared.name].inertia, i = e.resistance,
                    r = -Math.log(e.endSpeed / t.v0) / i;
                t.x0 = this.prevEvent.pageX, t.y0 = this.prevEvent.pageY, t.t0 = t.startEvent.timeStamp / 1e3, t.sx = t.sy = 0, t.modifiedXe = t.xe = (t.vx0 - r) / i, t.modifiedYe = t.ye = (t.vy0 - r) / i, t.te = r, t.lambda_v0 = i / t.v0, t.one_ve_v0 = 1 - e.endSpeed / t.v0
            }, autoScrollMove: function (t) {
                if (this.interacting() && $(this.target, this.prepared.name)) {
                    if (this.inertiaStatus.active) return void(_e.x = _e.y = 0);
                    var e, i, s, n, o = this.target.options[this.prepared.name].autoScroll,
                        a = o.container || z(this.element);
                    if (r(a)) n = t.clientX < _e.margin, e = t.clientY < _e.margin, i = t.clientX > a.innerWidth - _e.margin, s = t.clientY > a.innerHeight - _e.margin; else {
                        var h = D(a);
                        n = t.clientX < h.left + _e.margin, e = t.clientY < h.top + _e.margin, i = t.clientX > h.right - _e.margin, s = t.clientY > h.bottom - _e.margin
                    }
                    _e.x = i ? 1 : n ? -1 : 0, _e.y = s ? 1 : e ? -1 : 0, _e.isScrolling || (_e.margin = o.margin, _e.speed = o.speed, _e.start(this))
                }
            }, _updateEventTargets: function (t, e) {
                this._eventTarget = t, this._curEventTarget = e
            }
        }, J.prototype = {
            preventDefault: e, stopImmediatePropagation: function () {
                this.immediatePropagationStopped = this.propagationStopped = !0
            }, stopPropagation: function () {
                this.propagationStopped = !0
            }
        };
        for (var Je = {}, Qe = ["dragStart", "dragMove", "resizeStart", "resizeMove", "gestureStart", "gestureMove", "pointerOver", "pointerOut", "pointerHover", "selectorDown", "pointerDown", "pointerMove", "pointerUp", "pointerCancel", "pointerEnd", "addPointer", "removePointer", "recordPointer", "autoScrollMove"], Ze = 0, ti = Qe.length; ti > Ze; Ze++) {
            var ei = Qe[Ze];
            Je[ei] = K(ei)
        }
        Ce.indexOfElement = function (t, e) {
            e = e || fe;
            for (var i = 0; i < this.length; i++) {
                var r = this[i];
                if (r.selector === t && r._context === e || !r.selector && r._element === t) return i
            }
            return -1
        }, Ce.get = function (t, e) {
            return this[this.indexOfElement(t, e && e.context)]
        }, Ce.forEachSelector = function (t) {
            for (var e = 0; e < this.length; e++) {
                var i = this[e];
                if (i.selector) {
                    var r = t(i, i.selector, i._context, e, this);
                    if (void 0 !== r) return r
                }
            }
        }, oe.prototype = {
            setOnEvents: function (t, e) {
                return "drop" === t ? (a(e.ondrop) && (this.ondrop = e.ondrop), a(e.ondropactivate) && (this.ondropactivate = e.ondropactivate), a(e.ondropdeactivate) && (this.ondropdeactivate = e.ondropdeactivate), a(e.ondragenter) && (this.ondragenter = e.ondragenter), a(e.ondragleave) && (this.ondragleave = e.ondragleave), a(e.ondropmove) && (this.ondropmove = e.ondropmove)) : (t = "on" + t, a(e.onstart) && (this[t + "start"] = e.onstart), a(e.onmove) && (this[t + "move"] = e.onmove), a(e.onend) && (this[t + "end"] = e.onend), a(e.oninertiastart) && (this[t + "inertiastart"] = e.oninertiastart)), this
            }, draggable: function (t) {
                return o(t) ? (this.options.drag.enabled = t.enabled === !1 ? !1 : !0, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^x$|^y$|^xy$/.test(t.axis) ? this.options.drag.axis = t.axis : null === t.axis && delete this.options.drag.axis, this) : p(t) ? (this.options.drag.enabled = t, this) : this.options.drag
            }, setPerAction: function (t, e) {
                for (var i in e) i in Oe[t] && (o(e[i]) ? (this.options[t][i] = d(this.options[t][i] || {}, e[i]), o(Oe.perAction[i]) && "enabled" in Oe.perAction[i] && (this.options[t][i].enabled = e[i].enabled === !1 ? !1 : !0)) : p(e[i]) && o(Oe.perAction[i]) ? this.options[t][i].enabled = e[i] : void 0 !== e[i] && (this.options[t][i] = e[i]))
            }, dropzone: function (t) {
                return o(t) ? (this.options.drop.enabled = t.enabled === !1 ? !1 : !0, this.setOnEvents("drop", t), /^(pointer|center)$/.test(t.overlap) ? this.options.drop.overlap = t.overlap : h(t.overlap) && (this.options.drop.overlap = Math.max(Math.min(1, t.overlap), 0)), "accept" in t && (this.options.drop.accept = t.accept), "checker" in t && (this.options.drop.checker = t.checker), this) : p(t) ? (this.options.drop.enabled = t, this) : this.options.drop
            }, dropCheck: function (t, e, i, r, s, n) {
                var o = !1;
                if (!(n = n || this.getRect(s))) return this.options.drop.checker ? this.options.drop.checker(t, e, o, this, s, i, r) : !1;
                var a = this.options.drop.overlap;
                if ("pointer" === a) {
                    var p, l, c = x(t), d = _(i, r);
                    c.x += d.x, c.y += d.y, p = c.x > n.left && c.x < n.right, l = c.y > n.top && c.y < n.bottom, o = p && l
                }
                var u = i.getRect(r);
                if ("center" === a) {
                    var g = u.left + u.width / 2, v = u.top + u.height / 2;
                    o = g >= n.left && g <= n.right && v >= n.top && v <= n.bottom
                }
                if (h(a)) {
                    var m = Math.max(0, Math.min(n.right, u.right) - Math.max(n.left, u.left)) * Math.max(0, Math.min(n.bottom, u.bottom) - Math.max(n.top, u.top)),
                        f = m / (u.width * u.height);
                    o = f >= a
                }
                return this.options.drop.checker && (o = this.options.drop.checker(t, e, o, this, s, i, r)), o
            }, dropChecker: function (t) {
                return a(t) ? (this.options.drop.checker = t, this) : null === t ? (delete this.options.getRect, this) : this.options.drop.checker
            }, accept: function (t) {
                return i(t) ? (this.options.drop.accept = t, this) : c(t) ? (this.options.drop.accept = t, this) : null === t ? (delete this.options.drop.accept, this) : this.options.drop.accept
            }, resizable: function (t) {
                return o(t) ? (this.options.resize.enabled = t.enabled === !1 ? !1 : !0, this.setPerAction("resize", t), this.setOnEvents("resize", t), /^x$|^y$|^xy$/.test(t.axis) ? this.options.resize.axis = t.axis : null === t.axis && (this.options.resize.axis = Oe.resize.axis), p(t.preserveAspectRatio) ? this.options.resize.preserveAspectRatio = t.preserveAspectRatio : p(t.square) && (this.options.resize.square = t.square), this) : p(t) ? (this.options.resize.enabled = t, this) : this.options.resize
            }, squareResize: function (t) {
                return p(t) ? (this.options.resize.square = t, this) : null === t ? (delete this.options.resize.square, this) : this.options.resize.square
            }, gesturable: function (t) {
                return o(t) ? (this.options.gesture.enabled = t.enabled === !1 ? !1 : !0, this.setPerAction("gesture", t), this.setOnEvents("gesture", t), this) : p(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture
            }, autoScroll: function (t) {
                return o(t) ? t = d({actions: ["drag", "resize"]}, t) : p(t) && (t = {
                    actions: ["drag", "resize"],
                    enabled: t
                }), this.setOptions("autoScroll", t)
            }, snap: function (t) {
                var e = this.setOptions("snap", t);
                return e === this ? this : e.drag
            }, setOptions: function (t, e) {
                var i, r = e && n(e.actions) ? e.actions : ["drag"];
                if (o(e) || p(e)) {
                    for (i = 0; i < r.length; i++) {
                        var s = /resize/.test(r[i]) ? "resize" : r[i];
                        if (o(this.options[s])) {
                            var a = this.options[s][t];
                            o(e) ? (d(a, e), a.enabled = e.enabled === !1 ? !1 : !0, "snap" === t && ("grid" === a.mode ? a.targets = [ne.createSnapGrid(d({
                                offset: a.gridOffset || {
                                    x: 0,
                                    y: 0
                                }
                            }, a.grid || {}))] : "anchor" === a.mode ? a.targets = a.anchors : "path" === a.mode && (a.targets = a.paths), "elementOrigin" in e && (a.relativePoints = [e.elementOrigin]))) : p(e) && (a.enabled = e)
                        }
                    }
                    return this
                }
                var h = {}, l = ["drag", "resize", "gesture"];
                for (i = 0; i < l.length; i++) t in Oe[l[i]] && (h[l[i]] = this.options[l[i]][t]);
                return h
            }, inertia: function (t) {
                var e = this.setOptions("inertia", t);
                return e === this ? this : e.drag
            }, getAction: function (t, e, i, r) {
                var s = this.defaultActionChecker(t, i, r);
                return this.options.actionChecker ? this.options.actionChecker(t, e, s, this, r, i) : s
            }, defaultActionChecker: ee, actionChecker: function (t) {
                return a(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker
            }, getRect: function (t) {
                return t = t || this._element, this.selector && !i(t) && (t = this._context.querySelector(this.selector)), T(t)
            }, rectChecker: function (t) {
                return a(t) ? (this.getRect = t, this) : null === t ? (delete this.options.getRect, this) : this.getRect
            }, styleCursor: function (t) {
                return p(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor
            }, preventDefault: function (t) {
                return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : p(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault
            }, origin: function (t) {
                return c(t) ? (this.options.origin = t, this) : o(t) ? (this.options.origin = t, this) : this.options.origin
            }, deltaSource: function (t) {
                return "page" === t || "client" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource
            }, restrict: function (t) {
                if (!o(t)) return this.setOptions("restrict", t);
                for (var e, i = ["drag", "resize", "gesture"], r = 0; r < i.length; r++) {
                    var s = i[r];
                    if (s in t) {
                        var n = d({actions: [s], restriction: t[s]}, t);
                        e = this.setOptions("restrict", n)
                    }
                }
                return e
            }, context: function () {
                return this._context
            }, _context: fe, ignoreFrom: function (t) {
                return c(t) ? (this.options.ignoreFrom = t, this) : i(t) ? (this.options.ignoreFrom = t, this) : this.options.ignoreFrom
            }, allowFrom: function (t) {
                return c(t) ? (this.options.allowFrom = t, this) : i(t) ? (this.options.allowFrom = t, this) : this.options.allowFrom
            }, element: function () {
                return this._element
            }, fire: function (t) {
                if (!t || !t.type || !ce(We, t.type)) return this;
                var e, i, r, s = "on" + t.type, n = "";
                if (t.type in this._iEvents) for (e = this._iEvents[t.type], i = 0, r = e.length; r > i && !t.immediatePropagationStopped; i++) n = e[i].name, e[i](t);
                if (a(this[s]) && (n = this[s].name, this[s](t)), t.type in Ue && (e = Ue[t.type])) for (i = 0, r = e.length; r > i && !t.immediatePropagationStopped; i++) n = e[i].name, e[i](t);
                return this
            }, on: function (t, e, i) {
                var r;
                if (l(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), n(t)) {
                    for (r = 0; r < t.length; r++) this.on(t[r], e, i);
                    return this
                }
                if (o(t)) {
                    for (var s in t) this.on(s, t[s], e);
                    return this
                }
                if ("wheel" === t && (t = He), i = i ? !0 : !1, ce(We, t)) t in this._iEvents ? this._iEvents[t].push(e) : this._iEvents[t] = [e]; else if (this.selector) {
                    if (!Ae[t]) for (Ae[t] = {
                        selectors: [],
                        contexts: [],
                        listeners: []
                    }, r = 0; r < Te.length; r++) Be.add(Te[r], t, re), Be.add(Te[r], t, se, !0);
                    var a, h = Ae[t];
                    for (a = h.selectors.length - 1; a >= 0 && (h.selectors[a] !== this.selector || h.contexts[a] !== this._context); a--) ;
                    -1 === a && (a = h.selectors.length, h.selectors.push(this.selector), h.contexts.push(this._context), h.listeners.push([])), h.listeners[a].push([e, i])
                } else Be.add(this._element, t, e, i);
                return this
            }, off: function (t, e, i) {
                var r;
                if (l(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), n(t)) {
                    for (r = 0; r < t.length; r++) this.off(t[r], e, i);
                    return this
                }
                if (o(t)) {
                    for (var s in t) this.off(s, t[s], e);
                    return this
                }
                var a, h = -1;
                if (i = i ? !0 : !1, "wheel" === t && (t = He), ce(We, t)) a = this._iEvents[t], a && -1 !== (h = le(a, e)) && this._iEvents[t].splice(h, 1); else if (this.selector) {
                    var p = Ae[t], c = !1;
                    if (!p) return this;
                    for (h = p.selectors.length - 1; h >= 0; h--) if (p.selectors[h] === this.selector && p.contexts[h] === this._context) {
                        var d = p.listeners[h];
                        for (r = d.length - 1; r >= 0; r--) {
                            var u = d[r][0], g = d[r][1];
                            if (u === e && g === i) {
                                d.splice(r, 1), d.length || (p.selectors.splice(h, 1), p.contexts.splice(h, 1), p.listeners.splice(h, 1), Be.remove(this._context, t, re), Be.remove(this._context, t, se, !0), p.selectors.length || (Ae[t] = null)), c = !0;
                                break
                            }
                        }
                        if (c) break
                    }
                } else Be.remove(this._element, t, e, i);
                return this
            }, set: function (t) {
                o(t) || (t = {}), this.options = d({}, Oe.base);
                var e, i = ["drag", "drop", "resize", "gesture"],
                    r = ["draggable", "dropzone", "resizable", "gesturable"], s = d(d({}, Oe.perAction), t[n] || {});
                for (e = 0; e < i.length; e++) {
                    var n = i[e];
                    this.options[n] = d({}, Oe[n]), this.setPerAction(n, s), this[r[e]](t[n])
                }
                var a = ["accept", "actionChecker", "allowFrom", "deltaSource", "dropChecker", "ignoreFrom", "origin", "preventDefault", "rectChecker", "styleCursor"];
                for (e = 0, ti = a.length; ti > e; e++) {
                    var h = a[e];
                    this.options[h] = Oe.base[h], h in t && this[h](t[h])
                }
                return this
            }, unset: function () {
                if (Be.remove(this._element, "all"), l(this.selector)) for (var t in Ae) for (var e = Ae[t], i = 0; i < e.selectors.length; i++) {
                    e.selectors[i] === this.selector && e.contexts[i] === this._context && (e.selectors.splice(i, 1), e.contexts.splice(i, 1), e.listeners.splice(i, 1), e.selectors.length || (Ae[t] = null)), Be.remove(this._context, t, re), Be.remove(this._context, t, se, !0);
                    break
                } else Be.remove(this, "all"), this.options.styleCursor && (this._element.style.cursor = "");
                return this.dropzone(!1), Ce.splice(le(Ce, this), 1), ne
            }
        }, oe.prototype.snap = ae(oe.prototype.snap, "Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping"), oe.prototype.restrict = ae(oe.prototype.restrict, "Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction"), oe.prototype.inertia = ae(oe.prototype.inertia, "Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia"), oe.prototype.autoScroll = ae(oe.prototype.autoScroll, "Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll"), oe.prototype.squareResize = ae(oe.prototype.squareResize, "Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square"), oe.prototype.accept = ae(oe.prototype.accept, "Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead"), oe.prototype.dropChecker = ae(oe.prototype.dropChecker, "Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead"), oe.prototype.context = ae(oe.prototype.context, "Interactable#context as a method is deprecated. It will soon be a DOM Node instead"), ne.isSet = function (t, e) {
            return -1 !== Ce.indexOfElement(t, e && e.context)
        }, ne.on = function (t, e, i) {
            if (l(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), n(t)) {
                for (var r = 0; r < t.length; r++) ne.on(t[r], e, i);
                return ne
            }
            if (o(t)) {
                for (var s in t) ne.on(s, t[s], e);
                return ne
            }
            return ce(We, t) ? Ue[t] ? Ue[t].push(e) : Ue[t] = [e] : Be.add(fe, t, e, i), ne
        }, ne.off = function (t, e, i) {
            if (l(t) && -1 !== t.search(" ") && (t = t.trim().split(/ +/)), n(t)) {
                for (var r = 0; r < t.length; r++) ne.off(t[r], e, i);
                return ne
            }
            if (o(t)) {
                for (var s in t) ne.off(s, t[s], e);
                return ne
            }
            if (ce(We, t)) {
                var a;
                t in Ue && -1 !== (a = le(Ue[t], e)) && Ue[t].splice(a, 1)
            } else Be.remove(fe, t, e, i);
            return ne
        }, ne.enableDragging = ae(function (t) {
            return null !== t && void 0 !== t ? (Ne.drag = t, ne) : Ne.drag
        }, "interact.enableDragging is deprecated and will soon be removed."), ne.enableResizing = ae(function (t) {
            return null !== t && void 0 !== t ? (Ne.resize = t, ne) : Ne.resize
        }, "interact.enableResizing is deprecated and will soon be removed."), ne.enableGesturing = ae(function (t) {
            return null !== t && void 0 !== t ? (Ne.gesture = t, ne) : Ne.gesture
        }, "interact.enableGesturing is deprecated and will soon be removed."), ne.eventTypes = We, ne.debug = function () {
            var t = Me[0] || new j;
            return {
                interactions: Me,
                target: t.target,
                dragging: t.dragging,
                resizing: t.resizing,
                gesturing: t.gesturing,
                prepared: t.prepared,
                matches: t.matches,
                matchElements: t.matchElements,
                prevCoords: t.prevCoords,
                startCoords: t.startCoords,
                pointerIds: t.pointerIds,
                pointers: t.pointers,
                addPointer: Je.addPointer,
                removePointer: Je.removePointer,
                recordPointer: Je.recordPointer,
                snap: t.snapStatus,
                restrict: t.restrictStatus,
                inertia: t.inertiaStatus,
                downTime: t.downTimes[0],
                downEvent: t.downEvent,
                downPointer: t.downPointer,
                prevEvent: t.prevEvent,
                Interactable: oe,
                interactables: Ce,
                pointerIsDown: t.pointerIsDown,
                defaultOptions: Oe,
                defaultActionChecker: ee,
                actionCursors: qe,
                dragMove: Je.dragMove,
                resizeMove: Je.resizeMove,
                gestureMove: Je.gestureMove,
                pointerUp: Je.pointerUp,
                pointerDown: Je.pointerDown,
                pointerMove: Je.pointerMove,
                pointerHover: Je.pointerHover,
                eventTypes: We,
                events: Be,
                globalEvents: Ue,
                delegatedEvents: Ae,
                prefixedPropREs: Ke
            }
        }, ne.getPointerAverage = M, ne.getTouchBBox = P, ne.getTouchDistance = A, ne.getTouchAngle = O, ne.getElementRect = T, ne.getElementClientRect = D, ne.matchesSelector = de, ne.closest = I, ne.margin = ae(function (t) {
            return h(t) ? (Ye = t, ne) : Ye
        }, "interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead."), ne.supportsTouch = function () {
            return ke
        }, ne.supportsPointerEvent = function () {
            return Xe
        }, ne.stop = function (t) {
            for (var e = Me.length - 1; e >= 0; e--) Me[e].stop(t);
            return ne
        }, ne.dynamicDrop = function (t) {
            return p(t) ? (Pe = t, ne) : Pe
        }, ne.pointerMoveTolerance = function (t) {
            return h(t) ? (Re = t, this) : Re
        }, ne.maxInteractions = function (t) {
            return h(t) ? (Fe = t, this) : Fe
        }, ne.createSnapGrid = function (t) {
            return function (e, i) {
                var r = 0, s = 0;
                o(t.offset) && (r = t.offset.x, s = t.offset.y);
                var n = Math.round((e - r) / t.x), a = Math.round((i - s) / t.y), h = n * t.x + r, p = a * t.y + s;
                return {x: h, y: p, range: t.range}
            }
        }, pe(fe), Ge in Element.prototype && a(Element.prototype[Ge]) || (ve = function (t, e, i) {
            i = i || t.parentNode.querySelectorAll(e);
            for (var r = 0, s = i.length; s > r; r++) if (i[r] === t) return !0;
            return !1
        }), function () {
            for (var e = 0, i = ["ms", "moz", "webkit", "o"], r = 0; r < i.length && !t.requestAnimationFrame; ++r) Le = t[i[r] + "RequestAnimationFrame"], je = t[i[r] + "CancelAnimationFrame"] || t[i[r] + "CancelRequestAnimationFrame"];
            Le || (Le = function (t) {
                var i = (new Date).getTime(), r = Math.max(0, 16 - (i - e)), s = setTimeout(function () {
                    t(i + r)
                }, r);
                return e = i + r, s
            }), je || (je = function (t) {
                clearTimeout(t)
            })
        }(), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = ne), exports.interact = ne) : "function" == typeof define && define.amd ? define("interact", function () {
            return ne
        }) : t.interact = ne
    }
}("undefined" == typeof window ? void 0 : window);